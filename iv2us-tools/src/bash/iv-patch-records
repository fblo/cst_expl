#!/bin/bash

if [ ! -f /opt/apps/iv-patch-records/conf/conf.inc ]; then
	echo "Un fichier /opt/apps/iv-patch-records/conf/conf.inc est nécessaire (c'est écrit dans le MD de livraison pourtant)"
	exit 1 
fi
source /opt/apps/iv-patch-records/conf/conf.inc
source /opt/apps/iv-patch-records/commons

if [[ "$TMP_DIR" == "" ]]; then
	echo "Le répertoire temporaire de travail pour convertir les wav en mp3 n'est pas précisé dans le fichier /opt/apps/iv-patch-records/conf/conf.inc (TMP_DIR)"
	exit 1
fi

wl=$1
projet=$2
serveur=$3
laps=$4
USAGE="""Usage : iv-patch-records WHITE_LABEL PROJET HOTE_CST [LAPS]
	WHITE_LABEL : On est obligé parce pour KEYYO par exemple il y a 2 marques différentes
	PROJET : Ben le projet quoi ... Allo ?
	HOTE_CST : Pfff, le serveur con-6-temps.
	LAPS : Combien de temps en minutes on remonte en arrière pour scruter les logs binaires à la recherche du last_record. Le max c'est 60 parce que je ne veux pas faire un algo qui détermine s'il faut plus de deux fichiers de logs binaires à parcourir. Les 5 dernières minutes ne sont pas prises en compte pour ne pas travailler sur les mêmes records que le serveur IAP. Par défaut c'est 15.

"""

if [[ "$projet" == "" || "$serveur" == "" ]]; then
	echo -e "$USAGE"
	exit 1
fi
if [[ "$laps" == "" ]]; then
	laps=15
fi
if [[ "$laps" -gt 60 ]]; then
	echo 
	echo ">>> MAIS NON ! Le max c'est 60, c'est marqué là : "
	echo
	echo -e "$USAGE"
	exit 1
fi

# On détermine s'il n'y a qu'un ou deux fichiers de log à parcourir 
# En utilisant les facilités SQL
dateheure_min=$(sql_query "SET time_zone = 'UTC';select date_format(now() - interval $laps minute,'%Y%m%d%H')" TMP)
dateheure_max=$(sql_query "SET time_zone = 'UTC';select date_format(now(),'%Y%m%d%H')" TMP)

sql_query "truncate tmp.recs" TMP
sql_query "truncate tmp.iap" TMP

if [[ "$dateheure_min" != "$dateheure_max" ]]; then
#| sed 's/\[\("[^"]*"\)[^]]*\]/\1/g' 	# Ne garde que la première valeur du tableaux json	
#| sed 's/[^{]*{\([^}]*\)}/\1/g'	# retire le début jusqu'à '{' et le dernier '}'
#| sed 's/"/#/g'			# Plus simple à manipuler avec awk
#| sed 's/^[ ]*\(.*\)  $/\1/g'		# Enlève les espaces en début et fin de ligne
#| awk 'BEGIN{FS=", "}{s="";for(i=1;i<=NF;i++){split($i,a,"#"); s=s "\"" a[4] "\","}print "insert into tmp.recs values " "(" substr(s,0,length(s)-1) ");"}'    # Crée une commande SQL d'insertion à partir de chaque ligne
	ssh $SSH_USER@$serveur "ivlog-debug /opt/consistent/logs/$projet/Logger/$projet/_/ccenter_ccxml/Ccxml/$serveur $dateheure_min all_id --all true -n 2 | grep last_record" | sed 's/\[\("[^"]*"\)[^]]*\]/\1/g' | sed 's/[^{]*{\([^}]*\)}/\1/g' | sed 's/"/#/g' | sed 's/^[ ]*\(.*\)  $/\1/g' | awk 'BEGIN{FS=", "}{s="";for(i=1;i<=NF;i++){split($i,a,"#"); s=s "\"" a[4] "\","}print "insert into tmp.recs values " "(" substr(s,0,length(s)-1) ");"}' | grep queue | mysql -N -h $TMP_DB_HOST $TMP_DB_NAME
else
	ssh $SSH_USER@$serveur "ivlog-debug /opt/consistent/logs/$projet/Logger/$projet/_/ccenter_ccxml/Ccxml/$serveur $dateheure_min all_id --all true -n 1 | grep last_record"  | sed 's/\[\("[^"]*"\)[^]]*\]/\1/g' | sed 's/[^{]*{\([^}]*\)}/\1/g' | sed 's/"/#/g' | sed 's/^[ ]*\(.*\)  $/\1/g' | awk 'BEGIN{FS=", "}{s="";for(i=1;i<=NF;i++){split($i,a,"#"); s=s "\"" a[4] "\","}print "insert into tmp.recs values " "(" substr(s,0,length(s)-1) ");"}' | grep queue | mysql -N -h $TMP_DB_HOST $TMP_DB_NAME
fi
store_path="$SSH_USER@$serveur:/opt/consistent/db/store/$projet/Store"

id_per_day=$(sql_query "select (m.max_id - m.min_id) / datediff(now(),v.stop_time) as id_per_day  from (select min(id) as min_id, max(id) as max_id from VocalRecords) m inner join VocalRecords v on m.min_id = id ;" IAP)
max_id=$(sql_query "select max(id) from VocalRecords;" IAP)
project_ref=$(sql_query "select id from Projects where project = \"$projet\" and whitelabel = \"$wl\";" IAP)

count=$(sql_query "select count(0) from (select * from  VocalRecords v where v.id > ($max_id - 15000) and v.project_ref = $project_ref) n where date(stop_time) = date(now())" IAP)
if [[ "$count" != "0" ]];then
	(echo -e "insert into tmp.iap values \c";sql_query 'select concat("(\"",ccc_path,"\",\"",status,"\")") from (select * from  VocalRecords v where v.id > ('$max_id' - 15000) and v.project_ref = '$project_ref') n where date(stop_time) = date(now())' IAP)|sed 's/$/,/' | sed '$ s/.$//' | mysql -N -h $TMP_DB_HOST $TMP_DB_NAME
fi

# On laisse 5 min au serveur IAP pour faire le boulot
sql_query "delete FROM tmp.recs where concat(substr(stop_time,1,10), ' ',substr(stop_time,12,8)) > now() - interval 5 minute" TMP;

while read uri start_time start_tz stop_time stop_tz source_type call_session_id call_id queue agent_session_id caller called;
do
	if [[ "$uri" == "" ]];then
		echo "Bon ben y a rien à faire, j'me casse"
		exit 0
	fi
	comm_ref=$(sql_query "select id from Communications where communication_id = unhex(sha1(\"$call_id\"))" IAP)
	if [[ "$comm_ref" == "" ]];then
		comm_ref=$(sql_query "insert into Communications(communication_id, original_communication_id,updated, \`from\`, \`to\`) select unhex(sha1('$call_id')), '$call_id', 0, '$caller','$called'; select last_insert_id();" IAP)
		log "SQL : $comm_ref = insert into Communications(communication_id, original_communication_id,updated,from,to) select unhex(sha1('$call_id')), '$call_id', 0, '$caller','$called';"
	fi
	queue_ref=$(sql_query "select id from VocalQueues where name='$queue'" IAP)
	wavfile=$(basename $uri)
	vocal_id=$(sql_query "insert into VocalRecords (project_ref, start_time, start_tz, stop_time, stop_tz, source_type, communication_ref, call_session_id, ccc_path, vocal_queue_ref, status) values($project_ref,\"$start_time\",\"$start_tz\",\"$stop_time\",\"$stop_tz\",\"$source_type\",$comm_ref,\"$call_session_id\",\"cdep://$uri\",$queue_ref,\"new\"); select last_insert_id()" IAP)
	log "SQL : $vocal_id = insert into VocalRecords (project_ref, start_time, start_tz, stop_time, stop_tz, source_type, communication_ref, call_session_id, ccc_path, vocal_queue_ref, status) values($project_ref,\"$start_time\",\"$start_tz\",\"$stop_time\",\"$stop_tz\",\"$source_type\",$comm_ref,\"$call_session_id\",\"cdep://$uri\",$queue_ref,\"new\");"
	if [[ "$?" == "0" ]]; then # Le VocalRecord n'existait pas, il faut aussi l'affecter à la bonne session
		session_id=$(sql_query "select id from Sessions where vocal_session_id = unhex(sha1(\"$agent_session_id\"));" IAP)
		if [[ "$session_id" == "" ]]; then
			log "ERREUR : Pas de session dans iveventsdb pour $agent_session_id"
		else
			sql_query "insert into VocalRecordsSessions(record_ref, session_ref) values($vocal_id, $session_id);" IAP
			log "SQL : insert into VocalRecordsSessions(record_ref, session_ref) values($vocal_id, $session_id);"

		fi
	else # Le VocalRecords existe déjà et est éventuellement à new (2ème cas de défaut) 
		vocal_id=""
		vocal_id=$(sql_query "select id from VocalRecords where project_ref=$project_ref and communication_ref=$comm_ref and deleted=0 and start_time='$start_time'" IAP)
	fi

	if [[ "$vocal_id" != "" ]]; then 
		hash_id=$(python -c "from hashids import Hashids;h=Hashids(salt='recordsapi hashids salt tartiflette', min_length = 8);print(h.encrypt($vocal_id));")
		log "INFO: Je copie $wavfile vers $hash_id.mp3, l'id est $vocal_id"
		scp $store_path/$uri/.node_content $TMP_DIR/$wavfile
		if [[ "$?" == "0" ]];then 
			wavsize=$(wc -c $TMP_DIR/$wavfile | awk '{print $1}')
			lame --quiet $TMP_DIR/$wavfile $TMP_DIR/$hash_id.mp3 
			/opt/apps/iv-patch-records/iv-move-records $TMP_DIR/$hash_id.mp3
			if [[ "$?" == "0" ]]; then
				sql_query "update VocalRecords set duration = round($wavsize/16000,0), status=\"completed\", try=try+1 where id=$vocal_id" IAP
				log "SQL : update VocalRecords set duration = round($wavsize/16000,0), status=\"completed\", try=try+1 where id=$vocal_id" 
			else
				log "ERREUR : Impossible de copier $TMP_DIR/$hash_id.mp3 vers sa destination vocal_record_id=$vocal_id"
			fi
		else
			log "ERREUR: scp $store_path/$uri/.node_content $TMP_DIR/$wavfile vocal_record_id=$vocal_id"
		fi
	fi
done < <(sql_query 'select substr(r.uri,8), substr(start_time,1,19),  substr(stop_time,length(start_time)-4), substr(stop_time,1,19),  substr(stop_time,length(stop_time)-4), source_type, call_session_id, call_id, queue, agent_session_id, caller, called from tmp.recs r left join tmp.iap i on r.uri = i.ccc_path where status is null and now() - interval '$laps' minute < concat(substr(stop_time,1,10), " ",substr(stop_time,12,8));' TMP | xargs -n 12)

